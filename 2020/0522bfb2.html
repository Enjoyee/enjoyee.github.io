<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="ExHddHS4l2jJeVIoVbd6DW3jyud2YKbgshu329Djev8">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"keee.top","root":"/","scheme":"Pisces","version":"8.0.0-rc.2","exturl":false,"sidebar":{"position":"left","Pisces | Gemini":280,"display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"./public/search.xml"};
  </script>

  <meta name="description" content="函数声明fun max(a: Int, b: Int): Int &#x3D; if(a&gt;b) a else b 关键字fun，名称max，括号内的参数列表，先参数名，冒号后面是参数类型，括号后面的冒号跟着返回值类型，如果没有返回值就把冒号跟返回值类型直接去掉，kotlin里面if是有结果的表达式。 变量声明val a &#x3D; 1val a: Int &#x3D; 1var b &#x3D; 2var b: Int &#x3D; 2">
<meta property="og:type" content="article">
<meta property="og:title" content="Kotlin基础">
<meta property="og:url" content="https://keee.top/2020/0522bfb2.html">
<meta property="og:site_name" content="小破站">
<meta property="og:description" content="函数声明fun max(a: Int, b: Int): Int &#x3D; if(a&gt;b) a else b 关键字fun，名称max，括号内的参数列表，先参数名，冒号后面是参数类型，括号后面的冒号跟着返回值类型，如果没有返回值就把冒号跟返回值类型直接去掉，kotlin里面if是有结果的表达式。 变量声明val a &#x3D; 1val a: Int &#x3D; 1var b &#x3D; 2var b: Int &#x3D; 2">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-05-22T10:05:53.000Z">
<meta property="article:modified_time" content="2020-05-22T10:05:53.000Z">
<meta property="article:author" content="Glimmer">
<meta property="article:tag" content="kotlin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://keee.top/2020/0522bfb2.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Kotlin基础 | 小破站</title>
  
    <script>
      function sendPageView() {
        if (CONFIG.hostname !== location.hostname) return;
        var uid = localStorage.getItem('uid') || (Math.random() + '.' + Math.random());
        localStorage.setItem('uid', uid);
        navigator.sendBeacon('https://www.google-analytics.com/collect', new URLSearchParams({
          v  : 1,
          tid: 'UA-167377793-1',
          cid: uid,
          t  : 'pageview',
          dp : encodeURIComponent(location.pathname)
        }));
      }
      document.addEventListener('pjax:complete', sendPageView);
      sendPageView();
    </script>


  <script data-pjax>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e5232fa4507e0cb3a6ce72bd2ff9f63b";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="小破站" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">小破站</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">の日常操作</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://keee.top/2020/0522bfb2.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpeg">
      <meta itemprop="name" content="Glimmer">
      <meta itemprop="description" content="IT互联日常收集">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="小破站">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Kotlin基础
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-05-22 18:05:53" itemprop="dateCreated datePublished" datetime="2020-05-22T18:05:53+08:00">2020-05-22</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">max</span><span class="params">(a: <span class="type">Int</span>, b: <span class="type">Int</span>)</span></span>: <span class="built_in">Int</span> = <span class="keyword">if</span>(a&gt;b) a <span class="keyword">else</span> b</span><br></pre></td></tr></tbody></table></figure>
<p>关键字<code>fun</code>，名称<code>max</code>，括号内的参数列表，先参数名，冒号后面是参数类型，括号后面的冒号跟着返回值类型，如果没有返回值就把冒号跟返回值类型直接去掉，<code>kotlin</code>里面<code>if</code>是有结果的表达式。</p>
<h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> b: <span class="built_in">Int</span> = <span class="number">2</span></span><br></pre></td></tr></tbody></table></figure>
<p>声明变量的关键字有两个不可变引用<code>val</code>、可变引用<code>var</code>，默认情况下尽可能用<code>val</code>去声明变量，仅在必要的时候把变量声明为<code>var</code>，这样可以让你的代码更接近函数式编程风格。声明变量的时候可以显式的指定变量的类型，也可以直接隐藏去掉(如果已经可以推断出类型)</p>
<h3 id="字符串格式化模板"><a href="#字符串格式化模板" class="headerlink" title="字符串格式化模板"></a>字符串格式化模板</h3><figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> name = <span class="string">"bob"</span></span><br><span class="line"><span class="keyword">val</span> sex = <span class="string">"男"</span></span><br><span class="line"><span class="keyword">val</span> age = <span class="number">100</span></span><br><span class="line">print(<span class="string">"<span class="subst">${name}</span>的性别为：<span class="variable">$sex</span>，年龄为：<span class="variable">$age</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：bob的性别为：男，年龄为：100</span></span><br></pre></td></tr></tbody></table></figure>
<p>可以直接用<code>$</code>符号对变量进行引用，还可以用<code>${}</code>这种对表达式进行引用，就像刚才的例子那样，<code>name</code>可以换成表达式进行使用。</p>
<a id="more"></a>

<h3 id="类和属性"><a href="#类和属性" class="headerlink" title="类和属性"></a>类和属性</h3><figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></tbody></table></figure>
<p>在<code>Java</code>中，声明一个<code>JavaBean</code>类的<code>Person</code>除了属性<code>name</code>外，一般还需要设置<code>setter</code>跟<code>getter</code>方法，在<code>Kotlin</code>中可以直接就像上面的例子那样就可以了，<code>Kotlin</code>中<code>public</code>是默认的可见性，可以忽略它，如果这个<code>bean</code>是不需要更改里面的属性的，上面的代码例子就已经完成了，如果需要像<code>Java</code>那样有<code>setter</code>方法对属性进行更改，那么可以把<code>val</code>改成<code>var</code>即可。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String)</span><br></pre></td></tr></tbody></table></figure>
<p>我们还可以自定义类属性的访问器</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">var</span> name: String) {</span><br><span class="line">    <span class="keyword">val</span> isMarried: <span class="built_in">Boolean</span></span><br><span class="line">        <span class="keyword">get</span>() = name == <span class="string">"Bob"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>单独声明一个变量<code>isMarried</code>，然后在<code>get()</code>方法中对其进行判断返回。</p>
<h3 id="枚举类enum-class和when"><a href="#枚举类enum-class和when" class="headerlink" title="枚举类enum class和when"></a>枚举类<code>enum class</code>和<code>when</code></h3><h4 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h4><figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">MyColor</span> </span>{</span><br><span class="line">    RED, GREEN, BLUE</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>Kotlin</code>中用了<code>enum class</code>两个关键字来声明枚举类，我们还可以给枚举类声明属性和方法。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="class"><span class="keyword">class</span> <span class="title">MyColor</span></span>(<span class="keyword">val</span> r: <span class="built_in">Int</span>, <span class="keyword">val</span> g: <span class="built_in">Int</span>, <span class="keyword">val</span> b: <span class="built_in">Int</span>) {</span><br><span class="line">    RED(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>), GREEN(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), BLUE(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">rgb</span><span class="params">()</span></span> = (r * <span class="number">256</span> + g) * <span class="number">256</span> + b</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>然后可以使用该变量、方法</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line">MyColor.BLUE.rgb()</span><br></pre></td></tr></tbody></table></figure>
<h4 id="when"><a href="#when" class="headerlink" title="when"></a><code>when</code></h4><p><code>kotlin</code>中的<code>when</code>代替了<code>Java</code>中的<code>switch</code>，跟<code>if</code>一样，<code>when</code>也是一个有返回值的表达式</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMyColor</span><span class="params">(color: <span class="type">MyColor</span>)</span></span> = <span class="keyword">when</span> (color) {</span><br><span class="line">    MyColor.RED -&gt; <span class="string">"红色"</span></span><br><span class="line">    MyColor.GREEN -&gt; <span class="string">"绿色"</span></span><br><span class="line">    MyColor.BLUE -&gt; <span class="string">"蓝色"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>对于分支还可以用逗号合并起来的，例如下面例子</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMyColor</span><span class="params">(color: <span class="type">MyColor</span>)</span></span> = <span class="keyword">when</span> (color) {</span><br><span class="line">    MyColor.RED -&gt; <span class="string">"红色"</span></span><br><span class="line">    MyColor.GREEN, MyColor.BLUE -&gt; <span class="string">"绿色、蓝色"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>when</code>还可以使用<code>else</code>作为分支，<code>when</code>的条件不像<code>Java</code>的<code>switch</code>只能使用枚举常量、字符串或者数字面值这种，<code>when</code>可以使用任何对象作为分支条件</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMyColor</span><span class="params">(color: <span class="type">MyColor</span>)</span></span> = <span class="keyword">when</span> (color) {</span><br><span class="line">    setOf(MyColor.RED) -&gt; <span class="string">"红色"</span></span><br><span class="line">    setOf(MyColor.GREEN, MyColor.BLUE) -&gt; <span class="string">"绿色、蓝色混合"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"其它颜色混合"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>when</code>还可以不带参数条件，分支条件结果为<code>true</code>或者<code>false</code>就行</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getMyColor</span><span class="params">(color: <span class="type">MyColor</span>)</span></span> = <span class="keyword">when</span> {</span><br><span class="line">    color == MyColor.RED -&gt; <span class="string">"红色"</span></span><br><span class="line">    color == MyColor.GREEN || color == MyColor.BLUE -&gt; <span class="string">"绿色、蓝色混合"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"其它颜色混合"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<h3 id="智能转换，合并类型检查和转换"><a href="#智能转换，合并类型检查和转换" class="headerlink" title="智能转换，合并类型检查和转换"></a>智能转换，合并类型检查和转换</h3><figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getTextViewText</span><span class="params">(cc : <span class="type">View</span>)</span></span>: String? {</span><br><span class="line">    <span class="keyword">if</span> (cc <span class="keyword">is</span> TextView) {</span><br><span class="line">        <span class="keyword">return</span> cc.text.toString()</span><br><span class="line">    }</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>上面的例子中，在<code>if</code>中使用了<code>is</code>关键字进行类型判断跟转换，所以在条件内部中可以直接使用<code>TextView</code>的内部方法，相对于已经把<code>cc</code>转换为<code>TextView</code>了，另外<code>String?</code>是<code>Kotlin</code>表示可以为空的变量表达方法。</p>
<h3 id="迭代：while、for"><a href="#迭代：while、for" class="headerlink" title="迭代：while、for"></a>迭代：<code>while</code>、<code>for</code></h3><p>这个跟<code>Java</code>中基本上一致，没什么新内容。<code>for</code>迭代可以使用区间和数列，用<code>..</code>运算符表示区间，一个代表起始值，一个表示结束值：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> oneToTen = <span class="number">1</span>..<span class="number">10</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>) {</span><br><span class="line">    print(index)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1、2、3、4、5</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">1</span> until <span class="number">5</span>) {</span><br><span class="line">    print(index)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：1、2、3、4</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">5</span> downTo <span class="number">1</span>) {</span><br><span class="line">    print(index)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：5、4、3、2、1</span></span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (index <span class="keyword">in</span> <span class="number">5</span> downTo <span class="number">1</span> step <span class="number">2</span>) {</span><br><span class="line">    print(index)</span><br><span class="line">}</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出：5、3、1</span></span><br></pre></td></tr></tbody></table></figure>
<p><code>step</code>表示步长</p>
<h3 id="关键字in"><a href="#关键字in" class="headerlink" title="关键字in"></a>关键字<code>in</code></h3><p>使用<code>in</code>运算符来检查一个值是否在某个区间中或者它的逆运算<code>!in</code>检查这个值是否不在某个区间内。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isLetter</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c <span class="keyword">in</span> <span class="string">'a'</span>..<span class="string">'z'</span> || c <span class="keyword">in</span> <span class="string">'A'</span>..<span class="string">'Z'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isNotDigit</span><span class="params">(c: <span class="type">Char</span>)</span></span> = c <span class="keyword">in</span> <span class="string">'0'</span>..<span class="string">'9'</span></span><br></pre></td></tr></tbody></table></figure>

<h3 id="函数定义与调用"><a href="#函数定义与调用" class="headerlink" title="函数定义与调用"></a>函数定义与调用</h3><p><code>Kotlin</code>没有使用自己的集合类，用的是标准的<code>Java</code>集合类，使得<code>Kotlin</code>可以更好的与<code>Java</code>代码交互，下面例子创建一些基本的集合类。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">set</span> = hashSetOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> map = hashMapOf(<span class="number">1</span> to <span class="string">"one"</span>, <span class="number">2</span> to <span class="string">"two"</span>, <span class="number">3</span> to <span class="string">"three"</span>)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="顶层函数"><a href="#顶层函数" class="headerlink" title="顶层函数"></a>顶层函数</h3><p><code>Kotlin</code>可以定义顶层函数，创建一个名为<code>KtEx</code>的<code>kt</code>文件，直接创建函数：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">join</span><span class="params">(source: <span class="type">String</span>, suffix: <span class="type">String</span>)</span></span>: String {</span><br><span class="line">    <span class="keyword">return</span> source.plus(suffix)</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>在<code>kotlin</code>的其它地方就可以直接调用该<code>join</code>函数，如果是<code>Java</code>中调用的话，系统已经自动生成名为<code>KtExKt</code>的类去引用该静态方法，<code>KtExKt.join(source, suffix)</code></p>
<h3 id="扩展函数和属性"><a href="#扩展函数和属性" class="headerlink" title="扩展函数和属性"></a>扩展函数和属性</h3><p>扩展函数很简单，理论上来说，它就是一个类的成员函数，不过是定义在类的外部而已，<code>Kotlin</code>为我们定义了很多扩展函数，例如集合类<code>List</code>中有<code>last()、max()</code>等扩展函数。我们也可以自己自定义扩展函数，为String来扩展一个成员函数，获取<code>String</code>的最后一个字符返回</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.glimmer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> String.<span class="title">lastChar</span><span class="params">()</span></span>: <span class="built_in">Char</span> = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们就可以用<code>String</code>类型的变量直接调用该方法了，<code>Java</code>调用跟刚才一样</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"abc"</span>.lastChar()</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight java"><table><tbody><tr><td class="code"><pre><span class="line">KtExKt.lastChar(“abc”);</span><br></pre></td></tr></tbody></table></figure>
<p>在扩展函数中，可以直接访问被扩展的类的其它方法和属性，注意，扩展函数并不允许你打破它的封装性，跟在内部定义的方法不同的是，扩展函数不能访问私有的或者是受保护的成员。</p>
<h4 id="导入扩展函数"><a href="#导入扩展函数" class="headerlink" title="导入扩展函数"></a>导入扩展函数</h4><p>扩展函数有时候会有命名冲突，<code>Kotlin</code>支持用和导入类一样的语法来导入某个函数</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.glimmer.lastChar</span><br></pre></td></tr></tbody></table></figure>
<p>还可以导入全部</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.glimmer.*</span><br></pre></td></tr></tbody></table></figure>
<p>可以使用关键字<code>as</code>来修改导入的名称，后面就可以直接使用该名称来进行调用</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.glimmer.lastChar <span class="keyword">as</span> last</span><br><span class="line"></span><br><span class="line"><span class="string">"abc"</span>.last()</span><br></pre></td></tr></tbody></table></figure>
<h4 id="扩展属性"><a href="#扩展属性" class="headerlink" title="扩展属性"></a>扩展属性</h4><p>扩展属性提供了一种方法用来扩展类的<code>API</code>，可以用来访问属性，用的是属性语法而不是函数的语法，尽管它们被称为属性，但是它们可以没有任何状态，因为没有合适的地方来存储它。扩展属性跟扩展函数一样，也像接收者的一个普通的成员属性一样，这里必须定义<code>getter</code>函数，因为没有支持的字段，因此没有默认的<code>getter</code>实现，同理，初始化也不可可以的，因为没有地方存储初始值。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> String.last: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>然后我们就可以直接用它的扩展属性了</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="string">"abc"</span>.last</span><br></pre></td></tr></tbody></table></figure>
<p>如果是在<code>StringBuilder</code>上定义一个相同的属性，这就可以设置为<code>var</code>，因为<code>StringBuilder</code>的内容是可变的。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> StringBuilder.lastChar: <span class="built_in">Char</span></span><br><span class="line">    <span class="keyword">get</span>() = <span class="keyword">get</span>(length - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">set</span>(filed) = setCharAt(length - <span class="number">1</span>, filed)</span><br></pre></td></tr></tbody></table></figure>
<h3 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h3><p>当你调用函数来创建一个列表的时候，可以传递任意个的参数给它进行初始化：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> list = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>该函数在库中的声明是：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T&gt;</span> <span class="title">listOf</span><span class="params">(<span class="keyword">vararg</span> elements: <span class="type">T</span>)</span></span>: List&lt;T&gt; = {...}</span><br></pre></td></tr></tbody></table></figure>
<p>可以发现<code>Kotlin</code>中的可变参数关键字是<code>vararg</code></p>
<h3 id="中缀调用和解构声明"><a href="#中缀调用和解构声明" class="headerlink" title="中缀调用和解构声明"></a>中缀调用和解构声明</h3><p>我们可以使用<code>mapOf</code>函数来创建<code>map</code></p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> map = mapOf(<span class="number">1</span> to <span class="string">"one"</span>, <span class="number">2</span> to <span class="string">"two"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>以上代码中的关键字’to’不是内置的结构，而是一种特殊的函数调用，被称为中缀调用。<br>在中缀调用中，没有添加额外的分隔符，函数名称是直接放在目标对象名称和参数之间的，就像以下的两种调用方式，它们是等价的：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="number">1</span> to <span class="string">"one"</span></span><br><span class="line"><span class="number">1</span>.to(<span class="string">"one"</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>中缀调用可以与只有一个参数的函数一起使用，无论是普通的函数还是扩展函数，要允许使用中缀符号调用函数需要使用<code>infix</code>修饰符来标记，下面是一个简单的<code>to</code>函数的声明：</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">infix</span> <span class="function"><span class="keyword">fun</span> Any.<span class="title">to</span><span class="params">(other: <span class="type">Any</span>)</span></span> = Pair(<span class="keyword">this</span>, other)</span><br></pre></td></tr></tbody></table></figure>
<p>在<code>Koltin</code>中可以把一个对象赋值给多个变量，这种操作叫做解构声明。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">val</span>(number, name) = <span class="number">1</span> to <span class="string">"one"</span></span><br><span class="line"><span class="comment">// 然后我们可以直接调用打印number跟name</span></span><br><span class="line">print(number)</span><br><span class="line">print(name)</span><br></pre></td></tr></tbody></table></figure>
<p>数据类会默认生成解构声明</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> price: <span class="built_in">Float</span>)</span><br></pre></td></tr></tbody></table></figure>
<p>然后就可以调用<code>Book</code>的解构声明<code>component1()</code>对应<code>name</code>，<code>component2()</code>对应<code>price</code><br>我们还可以为普通类自定义解构声明</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span></span>(<span class="keyword">var</span> name: String, <span class="keyword">var</span> price: <span class="built_in">Float</span>) {</span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component1</span><span class="params">()</span></span>: String {</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    }</span><br><span class="line"></span><br><span class="line">    <span class="keyword">operator</span> <span class="function"><span class="keyword">fun</span> <span class="title">component2</span><span class="params">()</span></span>: <span class="built_in">Float</span> {</span><br><span class="line">        <span class="keyword">return</span> price</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<hr>
<h3 id="类、对象、接口"><a href="#类、对象、接口" class="headerlink" title="类、对象、接口"></a>类、对象、接口</h3><p><code>Kotlin</code>的类和接口与<code>Java</code>的还是有点区别的，例如<code>Kotlin</code>的接口是可以包含属性声明的，默认声明都是<code>final</code>和<code>public</code>，父类中的方法如果需要在子类中重写的话需要添加<code>open</code>关键字。嵌套的类默认不是内部类，也没有包含对其外部类的隐式引用。<code>kotlin</code>除了<code>public</code>、<code>protected</code>、<code>private</code>修饰符外，还新增了<code>internal</code>表示模块内部中可见修饰符，一个模块就是一组一起编译的<code>kotlin</code>文件。</p>
<h4 id="内部类和嵌套类：默认是嵌套类"><a href="#内部类和嵌套类：默认是嵌套类" class="headerlink" title="内部类和嵌套类：默认是嵌套类"></a>内部类和嵌套类：默认是嵌套类</h4><p>跟<code>Java</code>一样，在<code>Kotlin</code>中也可以在一个类中声明另一个类，但是<code>kotlin</code>的嵌套类不能访问外部类的实例，它并没有像<code>Java</code>那样包含了对外部类的隐式引用，除非你特别做出了要求，在<code>class</code>前面加上<code>inner</code>关键字声明这是一个内部类。</p>
<h4 id="密封类sealed"><a href="#密封类sealed" class="headerlink" title="密封类sealed"></a>密封类<code>sealed</code></h4><p>当我们使用<code>when</code>作为表达式来赋值的时候，我们必须提供一个else分支来处理没有其它任何分支能匹配的情况。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Expr</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) : Expr</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr) : Expr</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> = </span><br><span class="line">    <span class="keyword">when</span>(e) {</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; e.value</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">        <span class="keyword">else</span> -&gt; -<span class="number">1</span></span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>加上密封类关键字后，<code>Kotlin</code>就会对可能创建的子类做出了一个的限制，所有的直接子类必须嵌套在父类中。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">sealed</span> <span class="class"><span class="keyword">class</span> <span class="title">Expr</span> </span>{</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Num</span></span>(<span class="keyword">val</span> value: <span class="built_in">Int</span>) : Expr()</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span>(<span class="keyword">val</span> left: Expr, <span class="keyword">val</span> right: Expr) : Expr()</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">eval</span><span class="params">(e: <span class="type">Expr</span>)</span></span>: <span class="built_in">Int</span> = </span><br><span class="line">    <span class="keyword">when</span>(e) {</span><br><span class="line">        <span class="keyword">is</span> Num -&gt; e.value</span><br><span class="line">        <span class="keyword">is</span> Sum -&gt; eval(e.left) + eval(e.right)</span><br><span class="line">    }</span><br></pre></td></tr></tbody></table></figure>
<p>加入<code>sealed</code>关键字后你就不需要再加上<code>else</code>分支处理其它情况了，<code>sealed</code>修饰符隐含的这个类是一个<code>open</code>类，不需要显示的添加<code>open</code>修饰符。</p>
<h4 id="声明一个带非默认构造方法或属性的类"><a href="#声明一个带非默认构造方法或属性的类" class="headerlink" title="声明一个带非默认构造方法或属性的类"></a>声明一个带非默认构造方法或属性的类</h4><p>一个简单的类的声明</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>(<span class="keyword">val</span> nickname: String)</span><br></pre></td></tr></tbody></table></figure>
<p>类所有的声明都在括号内，这段被括号围起来的语句块也叫做主构造方法，我们也可以自己显式的去声明一个构造方法。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(_nickname: String) {</span><br><span class="line">    <span class="keyword">val</span> nickname: String</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">init</span> {</span><br><span class="line">        nickname = _nickname</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p><code>constructor</code>用来声明构造方法，<code>init</code>是用来引入一个初始化语句块，这种语句块在类被创建的时候就会执行，可以与主构造方法一起使用，下面声明一个私有的构造方法。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">private</span> <span class="keyword">constructor</span></span>() {}</span><br></pre></td></tr></tbody></table></figure>
<p>一个类也可以有多个构造方法，像<code>Java</code>一样。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>{</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) {}</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attr: Attributeset) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>调用父类的构造方法</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyView</span> : <span class="type">View {</span></span></span><br><span class="line">    <span class="keyword">constructor</span>(context: Context) : <span class="keyword">super</span>(context) {}</span><br><span class="line">    <span class="keyword">constructor</span>(context: Context, attr: Attributeset) : <span class="keyword">super</span>(context, attr) {}</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>也可以使用<code>this</code>关键字调用本类中的构造方法。</p>
<h4 id="通过getter、setter访问支持的字段"><a href="#通过getter、setter访问支持的字段" class="headerlink" title="通过getter、setter访问支持的字段"></a>通过<code>getter</code>、<code>setter</code>访问支持的字段</h4><figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">constructor</span></span>(_nickname: String) {</span><br><span class="line">    <span class="keyword">val</span> nickname: String = _nickname</span><br><span class="line">    <span class="keyword">var</span> sex: String = <span class="string">""</span></span><br><span class="line">        <span class="keyword">set</span>(value) {</span><br><span class="line">            field = <span class="string">"<span class="variable">$value</span>.com"</span></span><br><span class="line">        }</span><br><span class="line">        <span class="keyword">get</span>() = <span class="string">"@<span class="variable">$field</span>"</span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<p>关键字<code>field</code>用来访问支持的字段的值</p>
<h4 id="数据类"><a href="#数据类" class="headerlink" title="数据类"></a>数据类</h4><p><code>Kotlin</code>中的数据类会帮忙自动生成通用的方法，例如<code>setter</code>、<code>getter</code>等。数据类的属性推荐使用只读属性<code>val</code>，如果需要更改对象数据，也提供了一个允许<code>copy</code>类的实例方法，在<code>copy</code>的同时修改某些属性的值。</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>(<span class="keyword">val</span> name: String)</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> pp = Person(<span class="string">"张三"</span>)</span><br><span class="line"><span class="keyword">val</span> pp2 = pp.copy(name = <span class="string">"李四"</span>)</span><br><span class="line">showToast(pp2.name)</span><br><span class="line"><span class="comment">// 弹框输出：李四</span></span><br></pre></td></tr></tbody></table></figure>

<h4 id="类的委托"><a href="#类的委托" class="headerlink" title="类的委托"></a>类的委托</h4><p>通过关键字<code>by</code>实现</p>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Base</span> </span>{</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">showTag</span><span class="params">(tag: <span class="type">String</span>)</span></span></span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseImpl</span> : <span class="type">Base {</span></span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">showTag</span><span class="params">(tag: <span class="type">String</span>)</span></span> {</span><br><span class="line">        println(tag)</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DriverBaseImpl</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> base: BaseImpl) : Base <span class="keyword">by</span> base</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line">DriverBaseImpl(BaseImpl()).showTag(<span class="string">"tag"</span>)</span><br></pre></td></tr></tbody></table></figure>

<h4 id="object关键字"><a href="#object关键字" class="headerlink" title="object关键字"></a><code>object</code>关键字</h4><p><code>Kotlin</code>中<code>object</code>关键字在多种情况下会出现，这个关键字定义一个类并同时创建一个实例：</p>
<ul>
<li>对象声明是定义单例的一种方式。</li>
<li>伴生对象可以持有工厂方法和其它与这个类先关，但在调用时并不依赖类实例的方法，它们的成员可以通过类名来访问，</li>
<li>对象表达式用来替代<code>Java</code>的匿名内部类。</li>
</ul>
<h5 id="对象声明，创建单例"><a href="#对象声明，创建单例" class="headerlink" title="对象声明，创建单例"></a>对象声明，创建单例</h5><figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> PayType {</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> allType = arrayListOf(<span class="string">"支付宝"</span>, <span class="string">"微信"</span>, <span class="string">"银联"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">printAllPayType</span><span class="params">()</span></span> {</span><br><span class="line">        <span class="keyword">for</span> (payType <span class="keyword">in</span> allType) {</span><br><span class="line">            println(payType)</span><br><span class="line">        }</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>
<figure class="highlight kotlin"><table><tbody><tr><td class="code"><pre><span class="line">PayType.printAllPayType()</span><br></pre></td></tr></tbody></table></figure>
<p>与类一样，一个对象声明可以包含属性、方法、初始化语句块等的声明，唯一不允许的是构造方法，与普通类实例不一样的是对象声明在定义的时候就立即创建了，不需要再代码的其它地方调用构造方法之类的。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechatpay.png" alt="Glimmer 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="Glimmer 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Glimmer
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://keee.top/2020/0522bfb2.html" title="Kotlin基础">https://keee.top/2020/0522bfb2.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/kotlin/" rel="tag"># kotlin</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/052242399.html" rel="prev" title="Kotlin常见作用域函数">
      <i class="fa fa-chevron-left"></i> Kotlin常见作用域函数
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/05227251.html" rel="next" title="Jenkins自动化构建Android">
      Jenkins自动化构建Android <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
    <script data-ad-client="ca-pub-7035366573410673" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
  </article>
  
  
  



          </div>
          
    
  <div class="comments">
    <div id="disqus_thread">
      <noscript>Please enable JavaScript to view the comments powered by Disqus.</noscript>
    </div>
  </div>
  

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#函数声明"><span class="nav-number">1.</span> <span class="nav-text">函数声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量声明"><span class="nav-number">2.</span> <span class="nav-text">变量声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串格式化模板"><span class="nav-number">3.</span> <span class="nav-text">字符串格式化模板</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类和属性"><span class="nav-number">4.</span> <span class="nav-text">类和属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#枚举类enum-class和when"><span class="nav-number">5.</span> <span class="nav-text">枚举类enum class和when</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举类"><span class="nav-number">5.1.</span> <span class="nav-text">枚举类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#when"><span class="nav-number">5.2.</span> <span class="nav-text">when</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#智能转换，合并类型检查和转换"><span class="nav-number">6.</span> <span class="nav-text">智能转换，合并类型检查和转换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#迭代：while、for"><span class="nav-number">7.</span> <span class="nav-text">迭代：while、for</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字in"><span class="nav-number">8.</span> <span class="nav-text">关键字in</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#函数定义与调用"><span class="nav-number">9.</span> <span class="nav-text">函数定义与调用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#顶层函数"><span class="nav-number">10.</span> <span class="nav-text">顶层函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#扩展函数和属性"><span class="nav-number">11.</span> <span class="nav-text">扩展函数和属性</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#导入扩展函数"><span class="nav-number">11.1.</span> <span class="nav-text">导入扩展函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#扩展属性"><span class="nav-number">11.2.</span> <span class="nav-text">扩展属性</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#可变参数"><span class="nav-number">12.</span> <span class="nav-text">可变参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#中缀调用和解构声明"><span class="nav-number">13.</span> <span class="nav-text">中缀调用和解构声明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类、对象、接口"><span class="nav-number">14.</span> <span class="nav-text">类、对象、接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内部类和嵌套类：默认是嵌套类"><span class="nav-number">14.1.</span> <span class="nav-text">内部类和嵌套类：默认是嵌套类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#密封类sealed"><span class="nav-number">14.2.</span> <span class="nav-text">密封类sealed</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#声明一个带非默认构造方法或属性的类"><span class="nav-number">14.3.</span> <span class="nav-text">声明一个带非默认构造方法或属性的类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#通过getter、setter访问支持的字段"><span class="nav-number">14.4.</span> <span class="nav-text">通过getter、setter访问支持的字段</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据类"><span class="nav-number">14.5.</span> <span class="nav-text">数据类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#类的委托"><span class="nav-number">14.6.</span> <span class="nav-text">类的委托</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#object关键字"><span class="nav-number">14.7.</span> <span class="nav-text">object关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#对象声明，创建单例"><span class="nav-number">14.7.1.</span> <span class="nav-text">对象声明，创建单例</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Glimmer"
      src="/images/avatar.jpeg">
  <p class="site-author-name" itemprop="name">Glimmer</p>
  <div class="site-description" itemprop="description">IT互联日常收集</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">7</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">6</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Enjoyee" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Enjoyee" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Glimmer</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/pisces/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

<script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">博客全站共8.4k字</span>
  <span class="post-meta-divider">|</span>
  本站总访问量<span id="busuanzi_value_site_pv"></span>次
  <span class="post-meta-divider">|</span>
  本站访客数<span id="busuanzi_value_site_uv"></span>人次
  <span class="post-meta-divider">|</span>
  本文总阅读量<span id="busuanzi_value_page_pv"></span>次
</div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="30" alpha="0.3" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

document.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/disqusjs@1/dist/disqusjs.css">

<script>
NexT.utils.loadComments(document.querySelector('#disqus_thread'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/disqusjs@1/dist/disqus.js', () => {
    window.dsqjs = new DisqusJS({
      api       : '' || 'https://disqus.com/api/',
      apikey    : 'm8WdBCWSgVFbQvBE0aq2JDVf2Eq38ddRzCKJ0B7Ot0p2BgkxTJ0vpib2ZWRKYAai',
      shortname : 'xiao-po-zhan',
      url       : "https://keee.top/2020/0522bfb2.html",
      identifier: "2020/0522bfb2.html",
      title     : "Kotlin基础",
    });
  }, window.DisqusJS);
});
</script>

    </div>
</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
